<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>反恐精英 - Counter-Strike Web Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            user-select: none;
        }
        
        #gameCanvas {
            border: 1px solid #333;
            cursor: crosshair;
        }
        
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #666;
        }
        
        .menu h1 {
            color: #ff6600;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .menu button {
            display: block;
            width: 200px;
            margin: 10px auto;
            padding: 15px;
            background: #333;
            color: white;
            border: 2px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .menu button:hover {
            background: #555;
            border-color: #ff6600;
        }
        
        .hud {
            position: absolute;
            color: white;
            font-family: monospace;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .health-armor {
            top: 10px;
            left: 10px;
        }
        
        .money {
            top: 10px;
            right: 10px;
        }
        
        .ammo {
            bottom: 10px;
            right: 10px;
        }
        
        .objective {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 16px;
            color: #ff6600;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff00;
        }
        
        .crosshair::before {
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            transform: translateY(-50%);
        }
        
        .crosshair::after {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            transform: translateX(-50%);
        }
        
        .shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #666;
            min-width: 400px;
        }
        
        .shop h2 {
            color: #ff6600;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .shop-category {
            margin-bottom: 15px;
        }
        
        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #333;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .shop-item:hover {
            background: #555;
        }
        
        .shop-item.owned {
            background: #2a5a2a;
        }
        
        .shop-item.cant-afford {
            background: #5a2a2a;
            cursor: not-allowed;
        }
        
        .hidden {
            display: none !important;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid #ff6600;
        }
        
        .game-over h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .win {
            color: #00ff00;
        }
        
        .lose {
            color: #ff0000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="menu">
        <h1>反恐精英</h1>
        <button onclick="startGame('hostage')">人质解救模式</button>
        <button onclick="startGame('bomb')">炸弹模式</button>
        <button onclick="showSettings()">设置</button>
    </div>
    
    <!-- Settings Menu -->
    <div id="settingsMenu" class="menu hidden">
        <h2>设置</h2>
        <div style="margin: 15px 0;">
            <label>音量: </label>
            <input type="range" id="volumeSlider" min="0" max="100" value="50" style="width: 150px;">
            <span id="volumeValue">50%</span>
        </div>
        <div style="margin: 15px 0;">
            <label>鼠标灵敏度: </label>
            <input type="range" id="sensitivitySlider" min="1" max="10" value="5" style="width: 150px;">
            <span id="sensitivityValue">5</span>
        </div>
        <div style="margin: 15px 0;">
            <label>难度: </label>
            <select id="difficultySelect" style="padding: 5px; background: #333; color: white; border: 1px solid #666;">
                <option value="easy">简单</option>
                <option value="normal" selected>普通</option>
                <option value="hard">困难</option>
            </select>
        </div>
        <button onclick="backToMainMenu()">返回</button>
    </div>
    
    <!-- Shop -->
    <div id="shop" class="shop hidden">
        <h2>武器商店</h2>
        <div class="shop-category">
            <h3>主武器</h3>
            <div class="shop-item" data-weapon="m4a1">
                <span>M4A1 突击步枪</span>
                <span>$3100</span>
            </div>
            <div class="shop-item" data-weapon="ak47">
                <span>AK-47 突击步枪</span>
                <span>$2700</span>
            </div>
            <div class="shop-item" data-weapon="awp">
                <span>AWP 狙击步枪</span>
                <span>$4750</span>
            </div>
        </div>
        <div class="shop-category">
            <h3>副武器</h3>
            <div class="shop-item" data-weapon="deagle">
                <span>沙漠之鹰</span>
                <span>$700</span>
            </div>
        </div>
        <div class="shop-category">
            <h3>投掷物</h3>
            <div class="shop-item" data-weapon="grenade">
                <span>高爆手雷</span>
                <span>$300</span>
            </div>
            <div class="shop-item" data-weapon="flashbang">
                <span>闪光弹</span>
                <span>$200</span>
            </div>
            <div class="shop-item" data-weapon="smoke">
                <span>烟雾弹</span>
                <span>$300</span>
            </div>
        </div>
        <div class="shop-category">
            <h3>装备</h3>
            <div class="shop-item" data-weapon="armor">
                <span>护甲</span>
                <span>$650</span>
            </div>
        </div>
        <button onclick="closeShop()" style="margin-top: 15px; width: 100%; padding: 10px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭商店</button>
    </div>
    
    <!-- HUD Elements -->
    <div id="healthArmor" class="hud health-armor">
        <div>生命值: <span id="health">100</span></div>
        <div>护甲: <span id="armor">0</span></div>
    </div>
    
    <div id="money" class="hud money">
        金钱: $<span id="moneyAmount">800</span>
    </div>
    
    <div id="ammo" class="hud ammo">
        <div><span id="currentAmmo">30</span> / <span id="totalAmmo">90</span></div>
        <div id="weaponName">M4A1</div>
    </div>
    
    <div id="objective" class="hud objective">
        <div id="objectiveText">消灭所有敌人</div>
        <div id="timer">时间: <span id="timeLeft">120</span>s</div>
    </div>
    
    <div id="crosshair" class="crosshair"></div>
    
    <!-- Game Over Screen -->
    <div id="gameOver" class="game-over hidden">
        <h1 id="gameOverText" class="win">胜利!</h1>
        <p id="gameOverDetails">任务完成</p>
        <button onclick="restartGame()" style="margin: 10px; padding: 15px 30px; background: #333; color: white; border: 2px solid #666; border-radius: 5px; cursor: pointer; font-size: 16px;">重新开始</button>
        <button onclick="backToMainMenu()" style="margin: 10px; padding: 15px 30px; background: #333; color: white; border: 2px solid #666; border-radius: 5px; cursor: pointer; font-size: 16px;">返回主菜单</button>
    </div>

    <script>
        // Game Variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'menu'; // menu, playing, shop, gameOver
        let gameMode = 'hostage'; // hostage, bomb
        let difficulty = 'normal';
        let volume = 0.5;
        let sensitivity = 5;
        
        // Game Objects
        let player = null;
        let enemies = [];
        let bullets = [];
        let explosions = [];
        let particles = [];
        let hostages = [];
        let bombSites = [];
        let walls = [];
        let boxes = [];
        
        // Game State
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let camera = { x: 0, y: 0 };
        let gameTime = 120;
        let roundNumber = 1;
        let ctWins = 0;
        let tWins = 0;
        
        // Audio Context for sound effects
        let audioContext = null;
        
        // Weapon Definitions
        const weapons = {
            glock: {
                name: 'Glock-18',
                damage: 28,
                fireRate: 400,
                accuracy: 0.7,
                recoil: 0.3,
                ammo: 20,
                maxAmmo: 120,
                reloadTime: 2.2,
                cost: 0,
                type: 'pistol'
            },
            deagle: {
                name: 'Desert Eagle',
                damage: 63,
                fireRate: 267,
                accuracy: 0.9,
                recoil: 0.8,
                ammo: 7,
                maxAmmo: 35,
                reloadTime: 2.2,
                cost: 700,
                type: 'pistol'
            },
            m4a1: {
                name: 'M4A1',
                damage: 33,
                fireRate: 666,
                accuracy: 0.8,
                recoil: 0.4,
                ammo: 30,
                maxAmmo: 90,
                reloadTime: 3.1,
                cost: 3100,
                type: 'rifle'
            },
            ak47: {
                name: 'AK-47',
                damage: 36,
                fireRate: 600,
                accuracy: 0.75,
                recoil: 0.5,
                ammo: 30,
                maxAmmo: 90,
                reloadTime: 2.5,
                cost: 2700,
                type: 'rifle'
            },
            awp: {
                name: 'AWP',
                damage: 115,
                fireRate: 41,
                accuracy: 0.99,
                recoil: 0.9,
                ammo: 10,
                maxAmmo: 30,
                reloadTime: 3.7,
                cost: 4750,
                type: 'sniper'
            },
            grenade: {
                name: '高爆手雷',
                damage: 98,
                cost: 300,
                type: 'grenade'
            },
            flashbang: {
                name: '闪光弹',
                cost: 200,
                type: 'grenade'
            },
            smoke: {
                name: '烟雾弹',
                cost: 300,
                type: 'grenade'
            }
        };
        
        // Player Class
        class Player {
            constructor(x, y, team) {
                this.x = x;
                this.y = y;
                this.team = team; // 'ct' or 't'
                this.angle = 0;
                this.health = 100;
                this.armor = 0;
                this.money = 800;
                this.speed = 2;
                this.currentWeapon = team === 'ct' ? 'm4a1' : 'ak47';
                this.weapons = {
                    [this.currentWeapon]: {
                        ammo: weapons[this.currentWeapon].ammo,
                        totalAmmo: weapons[this.currentWeapon].maxAmmo
                    },
                    glock: {
                        ammo: weapons.glock.ammo,
                        totalAmmo: weapons.glock.maxAmmo
                    }
                };
                this.grenades = {};
                this.lastShot = 0;
                this.reloading = false;
                this.reloadStart = 0;
                this.moving = false;
                this.crouching = false;
                this.scoped = false;
                this.flashedUntil = 0;
            }
            
            update() {
                this.moving = false;
                
                // Movement
                if (keys['w'] || keys['W']) {
                    this.x += Math.cos(this.angle - Math.PI/2) * this.speed;
                    this.y += Math.sin(this.angle - Math.PI/2) * this.speed;
                    this.moving = true;
                }
                if (keys['s'] || keys['S']) {
                    this.x -= Math.cos(this.angle - Math.PI/2) * this.speed;
                    this.y -= Math.sin(this.angle - Math.PI/2) * this.speed;
                    this.moving = true;
                }
                if (keys['a'] || keys['A']) {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    this.moving = true;
                }
                if (keys['d'] || keys['D']) {
                    this.x -= Math.cos(this.angle) * this.speed;
                    this.y -= Math.sin(this.angle) * this.speed;
                    this.moving = true;
                }
                
                // Walking speed modifier
                if (keys['Shift']) {
                    this.speed = 1;
                } else {
                    this.speed = 2;
                }
                
                // Reload
                if (keys['r'] || keys['R']) {
                    this.reload();
                }
                
                // Weapon switching
                if (keys['1']) {
                    this.switchWeapon('primary');
                }
                if (keys['2']) {
                    this.switchWeapon('secondary');
                }
                
                // Check reload completion
                if (this.reloading && Date.now() - this.reloadStart > weapons[this.currentWeapon].reloadTime * 1000) {
                    this.completeReload();
                }
                
                // Collision detection
                this.checkCollisions();
                
                // Update camera
                camera.x = this.x - canvas.width / 2;
                camera.y = this.y - canvas.height / 2;
            }
            
            checkCollisions() {
                // Check wall collisions
                for (let wall of walls) {
                    if (this.x > wall.x && this.x < wall.x + wall.width &&
                        this.y > wall.y && this.y < wall.y + wall.height) {
                        // Simple collision resolution
                        let overlapX = Math.min(this.x - wall.x, wall.x + wall.width - this.x);
                        let overlapY = Math.min(this.y - wall.y, wall.y + wall.height - this.y);
                        
                        if (overlapX < overlapY) {
                            this.x += this.x < wall.x + wall.width/2 ? -overlapX : overlapX;
                        } else {
                            this.y += this.y < wall.y + wall.height/2 ? -overlapY : overlapY;
                        }
                    }
                }
                
                // Keep player in bounds
                this.x = Math.max(20, Math.min(1180, this.x));
                this.y = Math.max(20, Math.min(780, this.y));
            }
            
            shoot() {
                if (this.reloading || Date.now() - this.lastShot < 60000 / weapons[this.currentWeapon].fireRate) {
                    return;
                }
                
                if (!this.weapons[this.currentWeapon] || this.weapons[this.currentWeapon].ammo <= 0) {
                    return;
                }
                
                this.weapons[this.currentWeapon].ammo--;
                this.lastShot = Date.now();
                
                // Calculate bullet trajectory with recoil
                let accuracy = weapons[this.currentWeapon].accuracy;
                if (this.moving) accuracy *= 0.7;
                if (this.crouching) accuracy *= 1.3;
                if (this.scoped) accuracy *= 1.5;
                
                let spread = (1 - accuracy) * 0.2;
                let bulletAngle = this.angle + (Math.random() - 0.5) * spread;
                
                bullets.push(new Bullet(
                    this.x + Math.cos(this.angle) * 30,
                    this.y + Math.sin(this.angle) * 30,
                    bulletAngle,
                    weapons[this.currentWeapon].damage,
                    this.team
                ));
                
                // Muzzle flash effect
                particles.push(new MuzzleFlash(
                    this.x + Math.cos(this.angle) * 30,
                    this.y + Math.sin(this.angle) * 30,
                    this.angle
                ));
                
                // Play shoot sound
                playSound('shoot');
                
                updateHUD();
            }
            
            reload() {
                if (this.reloading || !this.weapons[this.currentWeapon] || 
                    this.weapons[this.currentWeapon].ammo === weapons[this.currentWeapon].ammo ||
                    this.weapons[this.currentWeapon].totalAmmo === 0) {
                    return;
                }
                
                this.reloading = true;
                this.reloadStart = Date.now();
                playSound('reload');
            }
            
            completeReload() {
                let weapon = this.weapons[this.currentWeapon];
                let maxAmmo = weapons[this.currentWeapon].ammo;
                let needed = maxAmmo - weapon.ammo;
                let available = Math.min(needed, weapon.totalAmmo);
                
                weapon.ammo += available;
                weapon.totalAmmo -= available;
                
                this.reloading = false;
                updateHUD();
            }
            
            switchWeapon(type) {
                if (type === 'primary') {
                    let primaryWeapons = Object.keys(this.weapons).filter(w => 
                        weapons[w].type === 'rifle' || weapons[w].type === 'sniper'
                    );
                    if (primaryWeapons.length > 0) {
                        this.currentWeapon = primaryWeapons[0];
                    }
                } else if (type === 'secondary') {
                    let secondaryWeapons = Object.keys(this.weapons).filter(w => 
                        weapons[w].type === 'pistol'
                    );
                    if (secondaryWeapons.length > 0) {
                        this.currentWeapon = secondaryWeapons[0];
                    }
                }
                updateHUD();
            }
            
            takeDamage(damage) {
                let actualDamage = damage;
                if (this.armor > 0) {
                    let armorDamage = Math.min(this.armor, damage * 0.5);
                    this.armor -= armorDamage;
                    actualDamage -= armorDamage;
                }
                
                this.health -= actualDamage;
                this.health = Math.max(0, this.health);
                
                updateHUD();
                
                if (this.health <= 0) {
                    endGame(false, '你被击败了!');
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.angle);
                
                // Draw player body
                ctx.fillStyle = this.team === 'ct' ? '#0066cc' : '#cc0000';
                ctx.fillRect(-8, -12, 16, 24);
                
                // Draw weapon
                ctx.fillStyle = '#333';
                ctx.fillRect(10, -2, 25, 4);
                
                // Draw health bar above player
                ctx.restore();
                
                if (this.health < 100) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - camera.x - 15, this.y - camera.y - 25, 30, 4);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x - camera.x - 15, this.y - camera.y - 25, 30 * (this.health / 100), 4);
                }
                
                // Flash effect
                if (Date.now() < this.flashedUntil) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * ((this.flashedUntil - Date.now()) / 3000)})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }
        
        // Enemy AI Class
        class Enemy {
            constructor(x, y, team) {
                this.x = x;
                this.y = y;
                this.team = team;
                this.angle = Math.random() * Math.PI * 2;
                this.health = 100;
                this.armor = Math.random() > 0.5 ? 50 : 0;
                this.speed = 1.5;
                this.currentWeapon = team === 't' ? 'ak47' : 'm4a1';
                this.weapons = {
                    [this.currentWeapon]: {
                        ammo: weapons[this.currentWeapon].ammo,
                        totalAmmo: weapons[this.currentWeapon].maxAmmo
                    }
                };
                this.lastShot = 0;
                this.target = null;
                this.state = 'patrol'; // patrol, engage, objective
                this.patrolTarget = { x: Math.random() * 1200, y: Math.random() * 800 };
                this.lastStateChange = Date.now();
                this.accuracy = difficulty === 'easy' ? 0.3 : difficulty === 'normal' ? 0.6 : 0.9;
                this.reactionTime = difficulty === 'easy' ? 1000 : difficulty === 'normal' ? 500 : 200;
                this.lastSeen = 0;
            }
            
            update() {
                this.updateAI();
                this.checkCollisions();
                
                // Shoot at target if in range and line of sight
                if (this.target && this.canSeeTarget() && 
                    Date.now() - this.lastShot > 60000 / weapons[this.currentWeapon].fireRate) {
                    this.shoot();
                }
            }
            
            updateAI() {
                let now = Date.now();
                
                // Find player
                let distToPlayer = Math.sqrt((this.x - player.x) ** 2 + (this.y - player.y) ** 2);
                
                if (distToPlayer < 300 && this.canSeeTarget()) {
                    this.target = player;
                    this.state = 'engage';
                    this.lastSeen = now;
                } else if (now - this.lastSeen > 3000) {
                    this.target = null;
                }
                
                switch (this.state) {
                    case 'patrol':
                        this.patrol();
                        break;
                    case 'engage':
                        this.engage();
                        break;
                    case 'objective':
                        this.moveToObjective();
                        break;
                }
                
                // State change logic
                if (now - this.lastStateChange > 5000) {
                    if (this.state === 'patrol' && Math.random() > 0.7) {
                        this.state = 'objective';
                    } else if (this.state === 'objective' && Math.random() > 0.8) {
                        this.state = 'patrol';
                    }
                    this.lastStateChange = now;
                }
            }
            
            patrol() {
                let dist = Math.sqrt((this.x - this.patrolTarget.x) ** 2 + (this.y - this.patrolTarget.y) ** 2);
                
                if (dist < 50) {
                    this.patrolTarget = { x: Math.random() * 1200, y: Math.random() * 800 };
                }
                
                this.moveTowards(this.patrolTarget.x, this.patrolTarget.y);
            }
            
            engage() {
                if (!this.target) {
                    this.state = 'patrol';
                    return;
                }
                
                // Move to cover or engage
                let distToTarget = Math.sqrt((this.x - this.target.x) ** 2 + (this.y - this.target.y) ** 2);
                
                if (distToTarget > 200) {
                    this.moveTowards(this.target.x, this.target.y);
                } else if (distToTarget < 100) {
                    // Move away to maintain distance
                    this.moveTowards(this.x - (this.target.x - this.x), this.y - (this.target.y - this.y));
                } else {
                    // Strafe
                    let perpAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x) + Math.PI/2;
                    this.x += Math.cos(perpAngle) * this.speed * (Math.random() > 0.5 ? 1 : -1);
                    this.y += Math.sin(perpAngle) * this.speed * (Math.random() > 0.5 ? 1 : -1);
                }
                
                // Aim at target
                this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            }
            
            moveToObjective() {
                let objective = null;
                
                if (gameMode === 'hostage' && hostages.length > 0) {
                    objective = hostages[0];
                } else if (gameMode === 'bomb' && bombSites.length > 0) {
                    objective = bombSites[0];
                }
                
                if (objective) {
                    this.moveTowards(objective.x, objective.y);
                }
            }
            
            moveTowards(targetX, targetY) {
                let angle = Math.atan2(targetY - this.y, targetX - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
                this.angle = angle;
            }
            
            canSeeTarget() {
                if (!this.target) return false;
                
                // Simple line of sight check
                let dx = this.target.x - this.x;
                let dy = this.target.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let steps = Math.floor(distance / 10);
                
                for (let i = 0; i < steps; i++) {
                    let checkX = this.x + (dx / steps) * i;
                    let checkY = this.y + (dy / steps) * i;
                    
                    for (let wall of walls) {
                        if (checkX > wall.x && checkX < wall.x + wall.width &&
                            checkY > wall.y && checkY < wall.y + wall.height) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            shoot() {
                if (!this.weapons[this.currentWeapon] || this.weapons[this.currentWeapon].ammo <= 0) {
                    return;
                }
                
                this.weapons[this.currentWeapon].ammo--;
                this.lastShot = Date.now();
                
                // AI accuracy based on difficulty
                let spread = (1 - this.accuracy) * 0.3;
                let bulletAngle = this.angle + (Math.random() - 0.5) * spread;
                
                bullets.push(new Bullet(
                    this.x + Math.cos(this.angle) * 30,
                    this.y + Math.sin(this.angle) * 30,
                    bulletAngle,
                    weapons[this.currentWeapon].damage,
                    this.team
                ));
                
                particles.push(new MuzzleFlash(
                    this.x + Math.cos(this.angle) * 30,
                    this.y + Math.sin(this.angle) * 30,
                    this.angle
                ));
            }
            
            checkCollisions() {
                for (let wall of walls) {
                    if (this.x > wall.x && this.x < wall.x + wall.width &&
                        this.y > wall.y && this.y < wall.y + wall.height) {
                        let overlapX = Math.min(this.x - wall.x, wall.x + wall.width - this.x);
                        let overlapY = Math.min(this.y - wall.y, wall.y + wall.height - this.y);
                        
                        if (overlapX < overlapY) {
                            this.x += this.x < wall.x + wall.width/2 ? -overlapX : overlapX;
                        } else {
                            this.y += this.y < wall.y + wall.height/2 ? -overlapY : overlapY;
                        }
                    }
                }
                
                this.x = Math.max(20, Math.min(1180, this.x));
                this.y = Math.max(20, Math.min(780, this.y));
            }
            
            takeDamage(damage) {
                let actualDamage = damage;
                if (this.armor > 0) {
                    let armorDamage = Math.min(this.armor, damage * 0.5);
                    this.armor -= armorDamage;
                    actualDamage -= armorDamage;
                }
                
                this.health -= actualDamage;
                this.health = Math.max(0, this.health);
                
                if (this.health <= 0) {
                    // Remove enemy and award money
                    let index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                        player.money += 300;
                        updateHUD();
                        
                        // Check win condition
                        if (enemies.length === 0) {
                            endGame(true, '消灭所有敌人!');
                        }
                    }
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.angle);
                
                // Draw enemy body
                ctx.fillStyle = this.team === 't' ? '#cc0000' : '#0066cc';
                ctx.fillRect(-8, -12, 16, 24);
                
                // Draw weapon
                ctx.fillStyle = '#333';
                ctx.fillRect(10, -2, 25, 4);
                
                ctx.restore();
                
                // Draw health bar
                if (this.health < 100) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - camera.x - 15, this.y - camera.y - 25, 30, 4);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x - camera.x - 15, this.y - camera.y - 25, 30 * (this.health / 100), 4);
                }
            }
        }
        
        // Bullet Class
        class Bullet {
            constructor(x, y, angle, damage, team) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 10;
                this.damage = damage;
                this.team = team;
                this.life = 100;
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.life--;
                
                // Check collisions with walls
                for (let wall of walls) {
                    if (this.x > wall.x && this.x < wall.x + wall.width &&
                        this.y > wall.y && this.y < wall.y + wall.height) {
                        this.life = 0;
                        // Add bullet hole
                        particles.push(new BulletHole(this.x, this.y));
                    }
                }
                
                // Check collisions with enemies
                if (this.team === 'ct') {
                    for (let enemy of enemies) {
                        let dist = Math.sqrt((this.x - enemy.x) ** 2 + (this.y - enemy.y) ** 2);
                        if (dist < 15) {
                            enemy.takeDamage(this.damage);
                            this.life = 0;
                            // Blood effect
                            for (let i = 0; i < 5; i++) {
                                particles.push(new BloodParticle(this.x, this.y));
                            }
                        }
                    }
                } else {
                    // Enemy bullet hitting player
                    let dist = Math.sqrt((this.x - player.x) ** 2 + (this.y - player.y) ** 2);
                    if (dist < 15) {
                        player.takeDamage(this.damage);
                        this.life = 0;
                        for (let i = 0; i < 5; i++) {
                            particles.push(new BloodParticle(this.x, this.y));
                        }
                    }
                }
                
                // Remove if out of bounds or life expired
                if (this.life <= 0 || this.x < 0 || this.x > 1200 || this.y < 0 || this.y > 800) {
                    let index = bullets.indexOf(this);
                    if (index > -1) {
                        bullets.splice(index, 1);
                    }
                }
            }
            
            draw() {
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.x - camera.x - 2, this.y - camera.y - 1, 4, 2);
            }
        }
        
        // Particle Classes
        class MuzzleFlash {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.life = 5;
                this.maxLife = 5;
            }
            
            update() {
                this.life--;
                if (this.life <= 0) {
                    let index = particles.indexOf(this);
                    if (index > -1) particles.splice(index, 1);
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.angle);
                
                let alpha = this.life / this.maxLife;
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.fillRect(0, -5, 20, 10);
                ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
                ctx.fillRect(0, -3, 15, 6);
                
                ctx.restore();
            }
        }
        
        class BulletHole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 300;
            }
            
            update() {
                this.life--;
                if (this.life <= 0) {
                    let index = particles.indexOf(this);
                    if (index > -1) particles.splice(index, 1);
                }
            }
            
            draw() {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class BloodParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 30;
                this.maxLife = 30;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // gravity
                this.life--;
                
                if (this.life <= 0) {
                    let index = particles.indexOf(this);
                    if (index > -1) particles.splice(index, 1);
                }
            }
            
            draw() {
                let alpha = this.life / this.maxLife;
                ctx.fillStyle = `rgba(150, 0, 0, ${alpha})`;
                ctx.fillRect(this.x - camera.x - 1, this.y - camera.y - 1, 2, 2);
            }
        }
        
        // Hostage Class
        class Hostage {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.rescued = false;
                this.health = 100;
            }
            
            draw() {
                if (this.rescued) return;
                
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.x - camera.x - 6, this.y - camera.y - 10, 12, 20);
                
                // Hostage icon
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x - camera.x - 4, this.y - camera.y - 8, 8, 6);
            }
        }
        
        // Bomb Site Class
        class BombSite {
            constructor(x, y, name) {
                this.x = x;
                this.y = y;
                this.name = name;
                this.planted = false;
                this.plantTime = 0;
                this.defusing = false;
                this.defuseTime = 0;
            }
            
            draw() {
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x - camera.x - 25, this.y - camera.y - 25, 50, 50);
                
                ctx.fillStyle = '#ff6600';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x - camera.x, this.y - camera.y - 30);
                
                if (this.planted) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x - camera.x - 10, this.y - camera.y - 5, 20, 10);
                    
                    // Bomb timer
                    let timeLeft = 45 - Math.floor((Date.now() - this.plantTime) / 1000);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(timeLeft.toString(), this.x - camera.x, this.y - camera.y + 20);
                }
            }
        }
        
        // Game Functions
        function initGame() {
            // Initialize audio context
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Audio not supported');
            }
            
            // Create map
            createMap();
            
            // Create player
            player = new Player(100, 100, 'ct');
            
            // Create enemies
            enemies = [];
            let enemyCount = difficulty === 'easy' ? 3 : difficulty === 'normal' ? 5 : 7;
            for (let i = 0; i < enemyCount; i++) {
                let x, y;
                do {
                    x = Math.random() * 1000 + 100;
                    y = Math.random() * 600 + 100;
                } while (Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) < 200);
                
                enemies.push(new Enemy(x, y, 't'));
            }
            
            // Initialize game objects
            bullets = [];
            explosions = [];
            particles = [];
            
            // Create objectives based on game mode
            if (gameMode === 'hostage') {
                hostages = [
                    new Hostage(800, 200),
                    new Hostage(850, 200),
                    new Hostage(900, 600)
                ];
                document.getElementById('objectiveText').textContent = '解救人质';
            } else if (gameMode === 'bomb') {
                bombSites = [
                    new BombSite(200, 600, 'A'),
                    new BombSite(1000, 200, 'B')
                ];
                document.getElementById('objectiveText').textContent = '阻止炸弹爆炸';
            }
            
            // Reset game state
            gameTime = 120;
            
            updateHUD();
        }
        
        function createMap() {
            walls = [];
            boxes = [];
            
            // Create walls (simple map layout)
            walls.push(
                { x: 0, y: 0, width: 1200, height: 20 }, // top
                { x: 0, y: 780, width: 1200, height: 20 }, // bottom
                { x: 0, y: 0, width: 20, height: 800 }, // left
                { x: 1180, y: 0, width: 20, height: 800 }, // right
                
                // Interior walls
                { x: 300, y: 100, width: 20, height: 200 },
                { x: 500, y: 300, width: 200, height: 20 },
                { x: 700, y: 100, width: 20, height: 150 },
                { x: 400, y: 500, width: 150, height: 20 },
                { x: 800, y: 400, width: 20, height: 200 },
                { x: 200, y: 600, width: 100, height: 20 }
            );
            
            // Create boxes for cover
            boxes.push(
                { x: 150, y: 150, width: 50, height: 50 },
                { x: 600, y: 200, width: 60, height: 40 },
                { x: 900, y: 500, width: 40, height: 60 },
                { x: 300, y: 400, width: 50, height: 50 },
                { x: 750, y: 300, width: 45, height: 45 }
            );
        }
        
        function startGame(mode) {
            gameMode = mode;
            gameState = 'playing';
            
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('settingsMenu').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            
            // Show HUD
            document.querySelectorAll('.hud').forEach(el => el.style.display = 'block');
            document.getElementById('crosshair').style.display = 'block';
            
            initGame();
            
            // Show shop at start of round
            setTimeout(() => {
                if (gameState === 'playing') {
                    showShop();
                }
            }, 500);
        }
        
        function showSettings() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('settingsMenu').classList.remove('hidden');
        }
        
        function backToMainMenu() {
            gameState = 'menu';
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('settingsMenu').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('shop').classList.add('hidden');
            
            // Hide HUD
            document.querySelectorAll('.hud').forEach(el => el.style.display = 'none');
            document.getElementById('crosshair').style.display = 'none';
        }
        
        function showShop() {
            if (gameState !== 'playing') return;
            
            gameState = 'shop';
            document.getElementById('shop').classList.remove('hidden');
            
            // Update shop items
            updateShopItems();
        }
        
        function closeShop() {
            gameState = 'playing';
            document.getElementById('shop').classList.add('hidden');
        }
        
        function updateShopItems() {
            const shopItems = document.querySelectorAll('.shop-item');
            
            shopItems.forEach(item => {
                const weaponName = item.dataset.weapon;
                const weapon = weapons[weaponName];
                
                if (!weapon) return;
                
                item.classList.remove('owned', 'cant-afford');
                
                if (player.weapons[weaponName] || (weaponName === 'armor' && player.armor > 0)) {
                    item.classList.add('owned');
                } else if (player.money < weapon.cost) {
                    item.classList.add('cant-afford');
                }
            });
        }
        
        function buyWeapon(weaponName) {
            const weapon = weapons[weaponName];
            if (!weapon || player.money < weapon.cost) return;
            
            if (weaponName === 'armor') {
                if (player.armor >= 100) return;
                player.armor = 100;
                player.money -= weapon.cost;
            } else if (weapon.type === 'grenade') {
                if (!player.grenades[weaponName]) {
                    player.grenades[weaponName] = 0;
                }
                if (player.grenades[weaponName] < 2) {
                    player.grenades[weaponName]++;
                    player.money -= weapon.cost;
                }
            } else {
                if (!player.weapons[weaponName]) {
                    player.weapons[weaponName] = {
                        ammo: weapon.ammo,
                        totalAmmo: weapon.maxAmmo
                    };
                    player.money -= weapon.cost;
                    
                    // Switch to new weapon if it's better
                    if (weapon.type === 'rifle' || weapon.type === 'sniper') {
                        player.currentWeapon = weaponName;
                    }
                }
            }
            
            updateShopItems();
            updateHUD();
        }
        
        function updateHUD() {
            document.getElementById('health').textContent = Math.ceil(player.health);
            document.getElementById('armor').textContent = Math.ceil(player.armor);
            document.getElementById('moneyAmount').textContent = player.money;
            
            if (player.weapons[player.currentWeapon]) {
                document.getElementById('currentAmmo').textContent = player.weapons[player.currentWeapon].ammo;
                document.getElementById('totalAmmo').textContent = player.weapons[player.currentWeapon].totalAmmo;
            }
            document.getElementById('weaponName').textContent = weapons[player.currentWeapon].name;
            
            document.getElementById('timeLeft').textContent = Math.max(0, gameTime);
        }
        
        function endGame(won, message) {
            gameState = 'gameOver';
            
            const gameOverEl = document.getElementById('gameOver');
            const gameOverText = document.getElementById('gameOverText');
            const gameOverDetails = document.getElementById('gameOverDetails');
            
            gameOverText.textContent = won ? '胜利!' : '失败!';
            gameOverText.className = won ? 'win' : 'lose';
            gameOverDetails.textContent = message;
            
            gameOverEl.classList.remove('hidden');
            
            if (won) {
                ctWins++;
                player.money += 3250;
            } else {
                tWins++;
            }
            
            playSound(won ? 'win' : 'lose');
        }
        
        function restartGame() {
            roundNumber++;
            startGame(gameMode);
        }
        
        // Sound Functions
        function playSound(type) {
            if (!audioContext) return;
            
            // Create simple sound effects using Web Audio API
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch (type) {
                case 'shoot':
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                    
                case 'reload':
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(250, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'win':
                    oscillator.frequency.setValueAtTime(523, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(volume * 0.4, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.6);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                    
                case 'lose':
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(volume * 0.4, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
            }
        }
        
        // Game Loop
        function gameLoop() {
            if (gameState === 'playing') {
                update();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            // Update game timer
            gameTime -= 1/60;
            if (gameTime <= 0) {
                endGame(false, '时间到!');
                return;
            }
            
            // Update player
            player.update();
            
            // Update enemies
            enemies.forEach(enemy => enemy.update());
            
            // Update bullets
            bullets.forEach(bullet => bullet.update());
            
            // Update particles
            particles.forEach(particle => particle.update());
            
            // Update bomb sites
            if (gameMode === 'bomb') {
                bombSites.forEach(site => {
                    if (site.planted && Date.now() - site.plantTime > 45000) {
                        endGame(false, '炸弹爆炸!');
                    }
                });
            }
            
            updateHUD();
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#2a4d3a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw map
            drawMap();
            
            // Draw objectives
            if (gameMode === 'hostage') {
                hostages.forEach(hostage => hostage.draw());
            } else if (gameMode === 'bomb') {
                bombSites.forEach(site => site.draw());
            }
            
            // Draw enemies
            enemies.forEach(enemy => enemy.draw());
            
            // Draw player
            player.draw();
            
            // Draw bullets
            bullets.forEach(bullet => bullet.draw());
            
            // Draw particles
            particles.forEach(particle => particle.draw());
        }
        
        function drawMap() {
            // Draw walls
            ctx.fillStyle = '#654321';
            walls.forEach(wall => {
                ctx.fillRect(wall.x - camera.x, wall.y - camera.y, wall.width, wall.height);
            });
            
            // Draw boxes
            ctx.fillStyle = '#8B4513';
            boxes.forEach(box => {
                ctx.fillRect(box.x - camera.x, box.y - camera.y, box.width, box.height);
                
                // Box outline
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(box.x - camera.x, box.y - camera.y, box.width, box.height);
            });
        }
        
        // Event Listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === 'Escape' && gameState === 'playing') {
                showShop();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'playing') return;
            
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            
            // Update player angle based on mouse position
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;
            player.angle = Math.atan2(mouse.y - centerY, mouse.x - centerX);
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (gameState !== 'playing') return;
            
            mouse.down = true;
            
            if (e.button === 0) { // Left click
                player.shoot();
            } else if (e.button === 2) { // Right click
                if (weapons[player.currentWeapon].type === 'sniper') {
                    player.scoped = !player.scoped;
                }
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            mouse.down = false;
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Shop event listeners
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('shop-item') && gameState === 'shop') {
                const weaponName = e.target.dataset.weapon;
                buyWeapon(weaponName);
            }
        });
        
        // Settings event listeners
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            volume = e.target.value / 100;
            document.getElementById('volumeValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
            sensitivity = e.target.value;
            document.getElementById('sensitivityValue').textContent = e.target.value;
        });
        
        document.getElementById('difficultySelect').addEventListener('change', (e) => {
            difficulty = e.target.value;
        });
        
        // Prevent context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Start game loop
        gameLoop();
        
        // Show initial message
        setTimeout(() => {
            if (gameState === 'menu') {
                alert('欢迎来到反恐精英! 使用WASD移动，鼠标控制视角和射击。');
            }
        }, 1000);
    </script>
</body>
</html>